---
title: "R Notebook"
output:
  html_document:
    df_print: paged
    toc: true
---



```{r}
library(tidyverse)
library(gridExtra)
library(cowplot)
library(fastDummies)
library(factoextra)
library(cluster)
library(dplyr)
```


#  Analisis exploratorio de datos

```{r, warning=F, echo=F, include=F}
datos = read.csv("base_trabajo_segmentacion.csv", sep=";") 
```

```{r, echo=F}
verTablaResumenPorCategoria <- function(df, titulo, titulosColumnas)
{
  tablaResumen <- df[, order(colSums(df), decreasing = T)] %>%
                  colSums() %>% 
                  format(scientific = F, big.mark = ",") %>%
                  knitr::kable(caption = titulo, col.names = titulosColumnas )
  return(tablaResumen)
}

obtenerTotalPorCategoria <- function(df)
{
  totalPorCategoria <- colSums(df)
  return(totalPorCategoria)
}

obtenerTotalPorCategoriaEnPorcentajes <- function(df)
{
  total <- obtenerTotalPorCategoria(df)
  totalPorCategoriaEnPorcentaje <- total/sum(total) * 100
  totalPorCategoriaEnPorcentaje <- round(totalPorCategoriaEnPorcentaje, 2)
  return(totalPorCategoriaEnPorcentaje)
}


crearAnalisisDescriptivoDeTickets <- function () 
{
  return(0)
}

```


## Analisis variables númericas

### Analisis descriptivo del valor promedio de los tickets de entrada


```{r}
# Arregla el nombre de las columnas para que se muestren con un mejor nombre en las tablas y graficos
valorPromedioTicketEntrada <-  datos[grep("en_vm.*", names(datos))] %>% 
                               setNames(c("Canal 1",
                                          "Canal 2",
                                          "Canal 3",
                                          "Canal 4",
                                          "Canal 5",
                                          "Canal 6",
                                          "Canal 7",
                                          "Canal 8",
                                          "Canal 9",
                                          "Canal 10",
                                          "Otros canales"))
```


```{r}
tablaResumenTicketPromedioDeEntrada <- verTablaResumenPorCategoria(valorPromedioTicketEntrada, "Valor promedio del ticket de entrada por canal", c("ValorTotalPorCanales"))
tablaResumenTicketPromedioDeEntrada
```





```{r}
#Total por porcentaje en cada canal
knitr::kable(obtenerTotalPorCategoriaEnPorcentajes(valorPromedioTicketEntrada), caption="Porcentaje de ingresos por canal", col.names="Porcentaje por canal")
```




### Analisis de transacciones promedio por canal


```{r}
# Arregla el nombre de las columnas para que se muestren con un mejor nombre en las tablas y graficos
transaccionesPromedioPorCanal <-  datos[grep("en_tx.*", names(datos))] %>% 
                               setNames(c("Canal 1","Canal 2",
                                          "Canal 3","Canal 4",
                                          "Canal 5","Canal 6",
                                          "Canal 7","Canal 8",
                                          "Canal 9","Canal 10",
                                          "Otros canales"))
```

```{r}
tablaResumenTicketPromedioDeEntrada <- verTablaResumenPorCategoria(transaccionesPromedioPorCanal, "Transacciones promedio de entrada por canal", c("Valor total por canal"))
tablaResumenTicketPromedioDeEntrada
```





```{r}
knitr::kable(obtenerTotalPorCategoriaEnPorcentajes(transaccionesPromedioPorCanal), caption="Porcentaje de transacciones por canal", col.names="Porcentaje por canal")
```



### Valor del ticket promedio de salida

```{r}
# Arregla el nombre de las columnas para que se muestren con un mejor nombre en las tablas y graficos
valorTicketPromedioSalida <-  datos[grep("sal_vm.*", names(datos))] %>% 
                               setNames(c("Canal 5","Canal 2",
                                          "Canal 8","Otros canales"))
```


```{r}
tablaResumenTransaccionesDeSalida <- verTablaResumenPorCategoria(valorTicketPromedioSalida, "Valor promedio del ticket de salida por canal", c("ValorTotalPorCanales"))
tablaResumenTransaccionesDeSalida
```






```{r}
knitr::kable(obtenerTotalPorCategoriaEnPorcentajes(valorTicketPromedioSalida), caption="Porcentaje de ingresos por canal", col.names="Porcentaje por canal")
```




### Transacciones promedio anuales de salida  


```{r}
# Arregla el nombre de las columnas para que se muestren con un mejor nombre en las tablas y graficos
transaccionesPromedioDeSalida <-  datos[grep("sal_tx.*", names(datos))] %>% 
                               setNames(c("Canal 5","Canal 2",
                                          "Canal 8","Otros canales"))
```


```{r}
verTablaResumenPorCategoria(transaccionesPromedioDeSalida, "Transacciones promedio de salida", "Dinero total de salida")
```




```{r}

knitr::kable(obtenerTotalPorCategoriaEnPorcentajes(transaccionesPromedioDeSalida), caption="Porcentaje de valor mensual por canal", col.names="Porcentaje por canal")
```







### Comparación de trafico por cada canal



```{r}
# Obtener los porcentajes por cada tipo de ticket
porcentajePorTicketDeEntrada <- obtenerTotalPorCategoriaEnPorcentajes(valorPromedioTicketEntrada)
porcentajePorTransaccionesPromedioEntrada <- obtenerTotalPorCategoriaEnPorcentajes(transaccionesPromedioPorCanal)
porcentajePorTicketDeSalida <- obtenerTotalPorCategoriaEnPorcentajes(valorTicketPromedioSalida)
porcentajePromedioDeSalida <- obtenerTotalPorCategoriaEnPorcentajes(transaccionesPromedioDeSalida)
```

```{r}
# Ajustar los nombres de los tickets de salida
porcentajePorTicketDeSalida <-  data.frame(canal = c("Canal 5", "Canal 2", "Canal 8", "Otros canales"),
                                           porcentajePorTicketDeSalida=porcentajePorTicketDeSalida)
porcentajePromedioDeSalida <-  data.frame(canal = c("Canal 5", "Canal 2", "Canal 8", "Otros canales"),
                                          porcentajePromedioDeSalida=porcentajePromedioDeSalida)
```

```{r}
# Ajustar los nombres de los tickets de entrada
infoCanalesPorcentajes <- data.frame(canal = c("Canal 1","Canal 2",
                            "Canal 3","Canal 4",
                            "Canal 5","Canal 6",
                            "Canal 7","Canal 8",
                            "Canal 9","Canal 10",
                            "Otros canales"))
infoCanalesPorcentajes$porcentajePorTicketDeEntrada = porcentajePorTicketDeEntrada
infoCanalesPorcentajes$porcentajePorTransaccionesPromedioEntrada = porcentajePorTransaccionesPromedioEntrada
```

```{r}
#Unir todos los porcentajes en un solo dataFrame
infoCanalesPorcentajes <- left_join(infoCanalesPorcentajes, porcentajePorTicketDeSalida, by="canal") 
infoCanalesPorcentajes <- left_join(infoCanalesPorcentajes, porcentajePromedioDeSalida, by="canal") 
infoCanalesPorcentajes <- infoCanalesPorcentajes %>%  mutate(across(everything(), .fns = ~replace_na(.,0))) 
```

```{r}
knitr::kable(infoCanalesPorcentajes, col.names = c("Canal", "Porcentaje por ticket de entrada", "Porcentaje por transacciones mensuales de entrada",
                                                   "Porcentaje por ticket de salida", "Porcentaje por transacciones de salida"))
```




```{r}
# Grafica de porcentaje de transacciones por categoria
ggplot(data=reshape2::melt(infoCanalesPorcentajes, id.vars = "canal"), aes(x=canal, y=value, fill=variable)) +
  geom_bar(width = 0.7, stat="identity", position=position_dodge()) + 
  theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1)) +
  labs(title="Porcentaje de dinero por cada categoria por cada canal", x="Canales", y="Porcentaje") 
  #coord_flip()
```





##  Variables categoricas

```{r, warning=F, echo=F, include=F}

datos = read.csv("base_trabajo_segmentacion.csv", sep=";") 
```

```{r}
# Funcion para crear una nueva columna con el porcentaje de las transacciones que ese cliente genera 
calcularTotalPorFilas <- function(df, regexColumnas, nombreColumnaTotal, nombreColumnaPorcentajes)
{
  dataFrameConTotalYPorcentajes <- df %>% mutate(
                                              ColumnaTotal = rowSums(select(.,contains(regexColumnas))),
                                              ColumnaPorcentajes= ColumnaTotal/sum(ColumnaTotal)*100
                                          ) 
  colnames(dataFrameConTotalYPorcentajes)[which(names(dataFrameConTotalYPorcentajes) == "ColumnaTotal")] <- 
    nombreColumnaTotal
  colnames(dataFrameConTotalYPorcentajes)[which(names(dataFrameConTotalYPorcentajes) == "ColumnaPorcentajes")] <- 
    nombreColumnaPorcentajes
                                          
  return(dataFrameConTotalYPorcentajes)
}
```


```{r}
# Calcular los porcentajes para cada tipo de ticket
datosConPorcentajesYTotales <-  datos %>% 
  calcularTotalPorFilas("en_vm", "total_tickets_de_entrada_cliente", "porcentaje_de_tickets_de_entrada_cliente") %>%
  calcularTotalPorFilas("en_tx", "total_transacciones_de_entrada_cliente", "porcentaje_transacciones_de_entrada_cliente") %>%
  calcularTotalPorFilas("sal_vm", "total_tickets_de_salida_cliente", "porcentaje_tickets_de_salida_cliente") %>% 
  calcularTotalPorFilas("sal_tx", "total_transacciones_de_salida_cliente", "porcentaje_transacciones_de_salida_cliente") 
```


```{r}
# Genera un dataFrame donde compara el top 80% con el resto 
resumenVariableCategoricaComparada <- function(dfMayoria, dfMinoria, columna)
{
    resumenDeMayoria <- dfMayoria %>%
      count(.dots=columna) %>%
      mutate(n = n/sum(n) * 100)
    
    resumenDeMinoria <- dfMinoria %>%
      count(.dots=columna) %>%
      mutate(n = n/sum(n) * 100)
    
    resumenComparativo <- resumenDeMayoria %>% inner_join(resumenDeMinoria, by= structure(names=columna, .Data=columna))
    return(resumenComparativo)
}
```



```{r}
# Se sacan los 300 mejores clientes que es la cantidad que genera el 80% de las transacciones
clientesQueGeneranLaMayoriaTicketsEntrada <- datosConPorcentajesYTotales %>%
                               filter(total_tickets_de_entrada_cliente != 0)  %>%  
                               arrange(desc(total_tickets_de_entrada_cliente)) %>%
                               head(n=300)
clientesQueGeneranMenorTicketsEntrada <- datosConPorcentajesYTotales %>%
                               filter(total_tickets_de_entrada_cliente != 0)  %>%  
                               arrange(desc(total_tickets_de_entrada_cliente)) %>%
                               slice(301: n())
```




```{r}
# Se escogen nombres que sean mas entendibles para el que lee el reporte
nombresLegibles <- c("Importaciones categorizadas", "Exportaciones categorizadas",
                     "Cuentas por pagar", "Cuentas por cobrar",
                     "Valor de inventarios", "Ventas fisicas", 
                     "Ventas electronicas", "Rotacion de inventarios",
                     "Rotacion de cuentas de pagar", "Rotacion de cuentas por cobrar",
                     "Ciclo de negocio", "Ciclo financiero"
                     )
names(nombresLegibles) <- c("impo_cv", "expo_vt", 
                            "cxp", "cxc", 
                            "totalinventory", "tiene_ventas_fisicas",
                            "tiene_ventas_electronicas", "rotacion_inventarios",
                            "rotacion_cxc", "rotacion_cxp", 
                            "ciclo_negocio", "ciclo_financiero"
                            )
```


```{r}
# Grafica los datos de una columna seleccionada
graficar_datos <- function (df, columnaDf, nombreMasLegible)
{
  titulo <- sprintf("Porcentaje de %s para cada subgrupo", nombreMasLegible)
  etiquetaMayoria <- sprintf("%s mayoria", nombreMasLegible)
  etiquetaMinoria <- sprintf("%s minoria", nombreMasLegible)
  datos <- reshape2::melt(df, id.vars=columnaDf)
  grafico <- ggplot(data=datos, aes(x=.data[[columnaDf]], y=value, fill=variable)) +
          geom_bar(stat="identity", position="stack") + 
          scale_fill_discrete(name = nombreMasLegible, labels = c(etiquetaMayoria, etiquetaMinoria)) +
          labs(title=titulo, x=nombreMasLegible, y="Porcentaje") + 
          theme(legend.position = "top")
  return(grafico) 
  
}

```


## Analisis clientes con mas tickets de salida



```{r}
# Con 500 clientes se genera el 80% de tickets de salida
clientesQueGeneranLaMayoriaTicketsSalida <- datosConPorcentajesYTotales %>%
                               filter(total_tickets_de_salida_cliente != 0)  %>%  
                               arrange(desc(total_tickets_de_salida_cliente)) %>%
                               head(n=500)

clientesQueGeneranMenorTicketsSalida <- datosConPorcentajesYTotales %>%
                               filter(total_tickets_de_salida_cliente != 0)  %>%  
                               arrange(desc(total_tickets_de_salida_cliente)) %>%
                               slice(501: n())
```


```{r}
# Compara las variables categoricas
for (columna in names(nombresLegibles))
{
  datosColumna <- resumenVariableCategoricaComparada(clientesQueGeneranLaMayoriaTicketsSalida, 
                                     clientesQueGeneranMenorTicketsSalida, columna)
  grafico <- graficar_datos(datosColumna, columna, nombresLegibles[[columna]])
  print(grafico)
}
```



#  Segmentacion jerarquica



```{r}


data<-read.table("base_trabajo_segmentacion.csv",sep = ";",header = TRUE)
data<-na.omit(data)

#Modificando las variables
datos_reducidos=mutate(data, en_vm_otros_ = en_vm_canal6+en_vm_canal7+en_vm_canal8+en_vm_canal9+en_vm_canal10+en_vm_otros,en_tx_otros_=en_tx_canal6+en_tx_canal7+en_tx_canal8+en_tx_canal9+en_tx_canal10+en_tx_otros)




borrar <- c("nit","en_vm_canal6","en_vm_canal7","en_vm_canal8","en_vm_canal9","en_vm_canal10","en_vm_otros","en_tx_canal6","en_tx_canal7","en_tx_canal8","en_tx_canal9","en_tx_canal10","en_tx_otros")
datos2 <- datos_reducidos[ , !(names(datos_reducidos) %in% borrar)]#En este paso se eliminan las variables sumadas ateriormente

datos_categoricos_seleccionados=datos2[19:34]#Se seleccionan y almacenan los datos categóricos

datos_categoricos=c("impo_cv","expo_vt","cxp","cxc","totalinventory","pagos_pj","pagos_pn","tiene_ventas_fisicas","tiene_ventas_electronicas","recaudos_pj","recaudos_pn","rotacion_inventarios","rotacion_cxc","rotacion_cxp","ciclo_negocio","ciclo_financiero")

datos_numericos <- datos2[ , !(names(datos2) %in% datos_categoricos)]#Para hacer los primeros análisi se dejan únicamente las variables cuantitativas del modelo
```

```{r}
# Descomposicion espectral
Sigma_t<-cov(scale(datos_numericos,center=T,scale=T))
descomp_espectr_t<-eigen(Sigma_t)
lambdas_t<-descomp_espectr_t$values
D_t<-descomp_espectr_t$vectors
```

```{r}
#En caso de ser necesario, se hará un análisis del ACP
acprincipales=prcomp(datos_numericos,scale=T)
```

```{r}
#Qué % de variablidad es explicada para cada componente:
prop_varianza <- acprincipales$sdev^2 / sum(acprincipales$sdev^2)
prop_varianza*100
```


```{r}
# Grafica de varianza acumulada 
prop_varianza_acum <- cumsum(prop_varianza)

ggplot(data = data.frame(prop_varianza_acum, pc = 1:20),
       aes(x = pc, y = prop_varianza_acum, group = 1)) +
  geom_point() +
  geom_line() +
  theme_bw() +
  labs(x = "Componente principal",
       y = "Prop. varianza explicada acumulada")
```


```{r, warning=F, echo=F}
# Visualizacion de datos con PCA 
datos_proyectados = acprincipales$x

grupo = read.csv("SegmentacionJerarquica.csv", sep=";")  %>% select(grupo)
grupo = grupo %>% mutate(grupo = as.factor(grupo))
#grupo = as.vector(grupo)
PC1 = datos_proyectados[,1]
PC2 = datos_proyectados[,2]
PC3 = datos_proyectados[,3]
#cbind(grupo, pC)

plotly::plot_ly( x=~PC1, y=~PC2, z=~PC3, color=grupo$grupo )
```

#  Analisis segmentacion jerarquica

Para analizar apropiadamente a los clientes, tendremos que observar su comportamiento
en dos categorias:

* Las variables numericas, en esta categoria podremos encontrar:
  * El valor promedio de entrada/salida del ticket por cada canal
  * Cantidad de transacciones mensuales de entrada/salida por cada canal 
  
* Las variables categoricas, la estratificación de los estados financieros
  * Informacion acerca de las importaciones
  * Informacion acerca de las exportaciones
  * Informacion de las cuentas por cobrar
  * Informacion de las cuentas por pagar
  * Informacion de los ciclos financieros
  * Informacion de los ciclos de negocio

Bajo esas categorias se le dara un identificar patrones compartidos por los
diferentes grupos asignados por la segmentación jerarquica. En total el algoritmo 
ha identificó 4 grupos, que se pueden interpretar como 2 sub-segmentos del top 80% 
de clientes que mas dinero genera a la empresa y el 20% inferior. Los segmentos 
identificados quedan de la siguiente manera:

* Top 80%:
  * Grupo 1: este grupo que mas ingresos genera
  * Grupo 3: este segundo grupo que mas ingresos genera
* El 20% inferior: 
  * Grupo 4: este grupo de esta categoría que mas ingresos genera
  * Grupo 2: este grupo es el que menos ingresos genera

Debido a que el grupo 1 es el que mas ingresos genera y tambien el grupo con el 
que mas se hacen transacciones de salida, este grupo va a predominar en esta 
primera frente a los otros grupos. 



```{r, warning=F, echo=F, include=F}
datos = read.csv("SegmentacionJerarquica.csv", sep=";")
```


## Total por grupo en cada canal

En la siguiente tabla se puede ver el total de dinero generados por los tickets 
por cada canal y grupo. Y a continuación, tambien se encontrarán varios graficos donde
se mostrará el porcentaje de participación de los grupos en cada uno de los canales.



```{r}
# Obtener el total por grupo y canal
totalPorGrupos <- datos %>% group_by(grupo) %>% 
                  summarise(across(everything(), sum))
totalPorGrupos[,1:31] / 10^9
```


```{r, echo=FALSE}
grupo <- c(1,2,3,4)

#Funcion que cambia el nombre a las columnas que cumplan con el REGEX
renombrarColumnas <- function(dataFrame, regexColumnas, nombresNuevos)
{
  return (dataFrame[grep(regexColumnas, names(dataFrame))] %>% 
                               setNames(nombresNuevos))
}

# Calcula el porcentaje en un DataFrame numerico
calcularPorcentajes <- function(dataFrame)
{
  return (dataFrame/ sum(dataFrame) * 100)
}

# Une la columna de grupos al DataFrame
agregarColumnaDeGrupos <- function(dataFrame)
{
  Grupo <- c("Grupo 1", "Grupo 2", "Grupo 3", "Grupo 4")
  return(cbind(Grupo, dataFrame))
}

# Esto era para un experimento. Agrega el tipo de ticket a un DataFrame 
agregarColumnaDeTipoTicket <- function(dataFrame, tipoDeTicket)
{
  return(cbind(dataFrame, tipoDeTicket))
}


# Los nuevos nombres de los canales 
nombresDeCanalesDeEntrada = c("Canal 1", "Canal 2", 
                           "Canal 3", "Canal 4",
                           "Canal 5", "Canal 6",     
                           "Canal 7", "Canal 8",
                           "Canal 9", "Canal 10",
                           "Otros canales")

nombresDeCanalesDeSalida = c("Canal 5","Canal 2", "Canal 8","Otros canales")

# Pone nombres mas legibles a los canales y calcula los porcentajes que genera cada grupo

# Modifica los tickets de entrada
regexTiquetDeEntrada = "en_vm.*"

TiquetsDeEntradaEnPorcentajes <-renombrarColumnas(totalPorGrupos, regexTiquetDeEntrada, nombresDeCanalesDeEntrada) %>%
                                calcularPorcentajes() %>%
                                agregarColumnaDeGrupos()

# Modifica las transacciones de entrada
regexTransaccionesDeEntrada = "en_tx.*"

transaccionesDeEntradaEnPorcentajes <-renombrarColumnas(totalPorGrupos, regexTransaccionesDeEntrada, nombresDeCanalesDeEntrada) %>%
                                calcularPorcentajes() %>%
                                agregarColumnaDeGrupos() 



# Modfica los tiquets de salida
regexTiquetDeSalida ="sal_vm.*"

ticketsDeSalidaEnPorcentajes <-renombrarColumnas(totalPorGrupos, regexTiquetDeSalida, nombresDeCanalesDeSalida) %>%
                                calcularPorcentajes() %>%
                                agregarColumnaDeGrupos() 

# Modifica las transacciones de salida
regexTiquetDeSalida ="sal_tx.*"
transaccionesDeSalidaEnPorcentajes <-renombrarColumnas(totalPorGrupos, regexTiquetDeSalida, nombresDeCanalesDeSalida) %>%
                                calcularPorcentajes() %>%
                                agregarColumnaDeGrupos() 
```




```{r, echo=FALSE}

graficarPorcentajesDeClientesEnCanales <- function  (dataFrame, tipoDeTiquet)
{
  grafica <- ggplot(data=reshape2::melt(dataFrame, id.vars ="Grupo"), aes(x=variable, y=value, fill=Grupo)) + 
            geom_bar(width = 0.7, stat="identity", position="stack") +
            labs(title= paste("Porcentaje de ventas", tipoDeTiquet,  "por cada grupo en cada canal"),
                 x="Canales", y="Porcentaje de clientes") + 
            theme(axis.text.x = element_text(angle = 45, vjust = 0.5, hjust=1))
  return(grafica)
}
```



```{r, fig.width=15, fig.height=12}
grid.arrange(graficarPorcentajesDeClientesEnCanales(TiquetsDeEntradaEnPorcentajes, "de ticket de entrada"),
             graficarPorcentajesDeClientesEnCanales(transaccionesDeEntradaEnPorcentajes, "de transacciones de entrada"),
             graficarPorcentajesDeClientesEnCanales(ticketsDeSalidaEnPorcentajes, "de tickets de salida"),
             graficarPorcentajesDeClientesEnCanales(transaccionesDeSalidaEnPorcentajes, "de transacciones de salida"),
             ncol = 2
             )
```



### Tickets de entrada 

#### Valor promedio del ticket anual

Para esta categoría podemos ver los canales y los grupos que son mas relevantes.
Podemos ver que el canal 1, 2, 5 y 7 son los canales mas importantes. Y que en 
ellos se agrupa el mas de 90% del valor de todos los tickets. Sin duda es una 
buena decisión seguir invirtiendo en estos canales. Como oportunidades de negocio
se observa que el canal 3, 6 y otros canales generan al rededor del un 8%, que pueden
ser una oportunidad para expandirse a futuro, el canal 6 parece ser un buen prospecto
para los grupos con desempeño mas bajo, ya que si los sumamos logran alcanzar al 
segundo mejor grupo. 

El canal 2 es donde todos llegan a tener una mayor participación en el cual el 
grupo 1 genera 8 billones de pesos, seguido por el 3 que genera 1.2 billones de pesos, 
seguido por el grupo 2 con 753 mil millones de pesos y grupo 4 con 629 mil millones 
de pesos.

A parte del canal anterior donde mas destaca el grupo 1 son en el 5 con un 16.6% del total,
el 1 con el 11.9% del total y el 4 con el 3.4% del total. 



```{r}
TiquetsDeEntradaEnPorcentajes
```

```{r}
 colSums(TiquetsDeEntradaEnPorcentajes[,-1])
```
#### Transacciones promedio mensual 


Los canales 4, 3, 1 y otros son los canales mas importantes para esta categoría.
De nuevo como en el valor de los tickets anuales, hay una canal que predomina, 
en este caso el canal 4 es el que mas transacciones genera agrupando mas del 
50% de las transacciones mensuales. Y los canales 3, 1 y otros agrupan un 10-20% 
de las transacciones cada uno. El único canal que mantiene una gran participación
en ambas categorías es el canal 1 con mas del 10% de participación. Los demas canales
manejan un volumen practicamente nulo. Una oportunidad que vale la pena explorar es
como aumentar el volumen de transacciones mensuales para el canal 2. 

Analizando mas a profundidad el grupo 1 vemos que su participación del total en 
los diferentes canales son: 46%, 15% y 11% en los canales 4,3 y otros respectivamente.
El grupo 3 tiene mayor participación en del: 6%, 3% y 1% en los canales 2, 1 y otros
respectivamente. El grupo 2 y el grupo 4 tienen menos del 3 % de participación total y 
sus canales preferido es son el 1,2 y 3. 



```{r}
transaccionesDeEntradaEnPorcentajes
```

```{r}
 colSums(transaccionesDeEntradaEnPorcentajes[,-1])
```


```{r}
 rowSums(transaccionesDeEntradaEnPorcentajes[,-1])
```

### Tickets de salida

#### Valor promedio del ticket anual

La gran mayoría de los tickets de salida van al canal 2 y 5 con un 98% de los
tickets totales. El canal 2 tiene el 70% de los tickets y el canal 5 tiene
el 20% de los mismos. Solo en el grupo 1 con el canal 2 y 5 suman al rededor 
de 12 billones de pesos. Y contando la contribución del grupo 3 estos suman
2 billones de pesos. Es decir en las cuentas contenidas en estos canales son 
tambien las que mas gasta dinero la compañía. Los demas canales no parecen ser 
significantes pero seguramente son servicios necesarios. 

```{r}
ticketsDeSalidaEnPorcentajes
```

```{r}
colSums(ticketsDeSalidaEnPorcentajes[,-1])
```



```{r}
rowSums(ticketsDeSalidaEnPorcentajes[,-1])
```

## Variables categoricas

```{r}
# Se modifica el DataFrame para cambiar el tipo de dato y graficar facilmente 
datosConFactores <-  datos %>%
  mutate(
    impo_cv = as.factor(impo_cv),
    expo_vt = as.factor(expo_vt),
    cxp = as.factor(cxp),
    cxc = as.factor(cxc),
    totalinventory = as.factor(totalinventory),
    tiene_ventas_fisicas = as.factor(tiene_ventas_fisicas),
    tiene_ventas_electronicas = as.factor(tiene_ventas_electronicas),
    rotacion_inventarios = as.factor(rotacion_inventarios),
    rotacion_cxc = as.factor(rotacion_cxc),
    rotacion_cxp = as.factor(rotacion_cxp),
    ciclo_negocio = as.factor(ciclo_negocio),
    ciclo_financiero = as.factor(ciclo_financiero),
    grupo = as.factor(grupo)
  )%>%
  mutate(
    grupo = fct_recode(grupo, "Grupo 1" = "1", "Grupo 2" = "2", "Grupo 3" = "3", "Grupo 4" = "4")
  )


```




```{r}
# Graficas de variables categoricas por grupo
columnasParaGraficar <- c("impo_cv", "expo_vt", "cxp", "cxc", "totalinventory", "tiene_ventas_fisicas",
                          "tiene_ventas_electronicas", "rotacion_inventarios", "rotacion_cxc",
                          "rotacion_cxp", "ciclo_negocio", "ciclo_financiero")

lista <- list()

for (columna in columnasParaGraficar)
{
  p1 <- ggplot(datosConFactores, aes(x=.data[[columna]], fill=grupo)) + 
    geom_bar(aes(y = (..count..)/sum(..count..)), position="stack") + 
    scale_y_continuous(labels=scales::percent)  +
    ylab("Porcentaje")  
  lista <- c(lista, list(p1))
  #plot(p1)
}
```


```{r, fig.width=14, fig.height=12}
do.call(grid.arrange, c(lista[1:6], nrow = 3))
```
```{r, fig.width=14, fig.height=12}
do.call(grid.arrange, c(lista[7:12], nrow = 3))
```




```{r}
DfConPagos_pj <- datosConFactores %>% select(grupo, pagos_pj)
DfConPagos_pj <- reshape2::melt(DfConPagos_pj, id.vars="grupo")
ggplot(DfConPagos_pj, aes(x=grupo, y=value, fill=grupo) ) + 
  geom_boxplot() +
  theme(legend.position = "none") + 
  labs(title= "Porcentaje de pagos a personas juridicas por grupo", x="Grupo", y="Porcentaje de pagos a personas juridicas")
```


```{r}
DfConPagos_pn <- datosConFactores %>% select(grupo, pagos_pn)
DfConPagos_pn <- reshape2::melt(DfConPagos_pn, id.vars="grupo")
ggplot(DfConPagos_pn, aes(x=grupo, y=value, fill=grupo) ) + 
  geom_boxplot() +
  theme(legend.position = "none") + 
  labs(title= "Porcentaje de pagos a personas naturales por grupo", x="Grupo", y="Porcentaje de pagos a personas naturales")
```




# Segmentacion K-means

```{r}
datos = read.csv("SegmentacionPCA.csv", sep=";")
```



```{r}
# Se modifica el DataFrame para cambiar el tipo de dato y graficar facilmente 
datosConFactores <-  datos %>%
  mutate(
    impo_cv = as.factor(impo_cv),
    expo_vt = as.factor(expo_vt),
    cxp = as.factor(cxp),
    cxc = as.factor(cxc),
    totalinventory = as.factor(totalinventory),
    tiene_ventas_fisicas = as.factor(tiene_ventas_fisicas),
    tiene_ventas_electronicas = as.factor(tiene_ventas_electronicas),
    rotacion_inventarios = as.factor(rotacion_inventarios),
    rotacion_cxc = as.factor(rotacion_cxc),
    rotacion_cxp = as.factor(rotacion_cxp),
    ciclo_negocio = as.factor(ciclo_negocio),
    ciclo_financiero = as.factor(ciclo_financiero),
    grupo = as.factor(grupo)
  )%>%
  mutate(
    grupo = fct_recode(grupo, "Grupo 1" = "1", "Grupo 2" = "2", "Grupo 3" = "3", "Grupo 4" = "4", "Grupo 5" = "5")
  )


```



```{r}
# Graficas de variables categoricas por grupo
columnasParaGraficar <- c("impo_cv", "expo_vt", "cxp", "cxc", "totalinventory", "tiene_ventas_fisicas",
                          "tiene_ventas_electronicas", "rotacion_inventarios", "rotacion_cxc",
                          "rotacion_cxp", "ciclo_negocio", "ciclo_financiero")

for (columna in columnasParaGraficar)
{
  p1 <- ggplot(datosConFactores, aes(x=.data[[columna]], fill=grupo)) + 
    geom_bar(aes(y = (..count..)/sum(..count..)), position="stack") + 
    scale_y_continuous(labels=scales::percent)  +
    ylab("Porcentaje")  
  plot(p1)
}
```


```{r}
#Test 

nit <- read.csv("base_trabajo_segmentacion.csv", sep=";")$nit
segConIds <- cbind(nit, datos)

anti_join(clientesQueGeneranLaMayoriaTicketsSalida,segConIds[segConIds$grupo==1,], by="nit")  %>% #drops all observations in df1 that match in df2.
anti_join(segConIds[segConIds$grupo==3,], by="nit") 


inner_join(clientesQueGeneranLaMayoriaTicketsSalida,segConIds[segConIds$grupo==1,], by="nit")
inner_join(clientesQueGeneranLaMayoriaTicketsSalida,segConIds[segConIds$grupo==3,], by="nit")
```



